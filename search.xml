<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>C++ Programming</title>
      <link href="/2021/03/19/c-programming/"/>
      <url>/2021/03/19/c-programming/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="C-Programming"><a href="#C-Programming" class="headerlink" title="C++ Programming"></a>C++ Programming</h1><h2 id="Types"><a href="#Types" class="headerlink" title="Types"></a>Types</h2><ul><li><p><strong>Every name (identifier) in a C++ program has a type associated with it</strong>. This type determines <u>what operations can be applied to the name</u> (that is, to the entity referred to by the name) and <u>how such operations are interpreted</u></p><pre class=" language-c++"><code class="language-c++">float x;//x is a loating-point variableint y=7;//y is an integer variable with the initial value 7float f(int);//f is a function taking an argument of type int and returning a floating-point number</code></pre><ul><li>Identifiers (标识符)：如Variables (变量)、Constants（常量）、Functions（函数）等</li><li>Literals（字面值）：如10，1.234，’A’，”Hello World”</li><li>Operators（操作符/运算符）</li><li>以上元素的合法组合，如Expression（表达式）等</li><li><img src="images/image-20210319114328639.png" alt="image-20210319114328639"></li><li><img src="images/image-20210319114410899.png" alt="image-20210319114410899"></li></ul></li><li><p>一个类型可被看成由两个集合构成：</p><ul><li>值集：描述了该类型变量的合法取值范围</li><li>操作集：描述了对值集中的元素能实施哪些运算</li></ul></li><li><p>类型的作用：</p><ul><li>决定其变量/实例的合法取值范围——值集（the Set of Values）</li><li>决定合法的操作（一般用操作符或函数表示）的范围——操作集（the Set of Operations）</li><li>决定变量的存储空间大小</li><li>区分名字相同、性质不同的符号，如变量、函数、操作符</li><li>决定将一种类型的值<strong>能否</strong>及<strong>如何</strong>转换成另一种类型的值</li><li><u>为编译程序提供依据，令其检查出程序中的一部分错误</u></li></ul></li></ul><h3 id="Booleans"><a href="#Booleans" class="headerlink" title="Booleans"></a>Booleans</h3><ul><li><p>名称：bool</p></li><li><p>值集：{true, false}</p></li><li><p>支持的运算</p><ul><li>逻辑运算：非（!） 与（&amp;&amp;）或（||）</li><li>算术运算：true和false可被替换成整数1和0</li></ul></li><li><p>数值/指针类型可转换为bool：0 equals false, others equal true</p></li><li><p>examples:</p><ul><li>you can use bool as the result of some conditions</li></ul><pre class=" language-c++"><code class="language-c++">bool is_open(File*);bool greater(int a,int b){return a>b;}</code></pre></li></ul><h3 id="Character-Types"><a href="#Character-Types" class="headerlink" title="Character Types"></a>Character Types</h3><ul><li><p>C++ provides a variety of character types</p><ul><li><p><strong>char</strong>: The default character type, is usually 8 bits</p><ul><li><pre class=" language-c++"><code class="language-c++">char c = 255; // 255 is ‘‘all ones,’ ’ hexadecimal 0xFFint i = c;//if a char is signed, 255 means -1, but unsigned means 255</code></pre></li></ul></li><li><p><strong>signed char</strong> : Like char, but guaranteed to be signed</p></li><li><p><strong>unsigned char</strong>: Like char, but guaranteed to be unsigned</p></li><li><p><strong>wchar_t</strong>: The size of it is <strong>implementation-defined</strong> (Provided for a larger character set such as unicode), is usually 2 bytes</p></li><li><p><strong>char16_t</strong>: A type for holding 16-bit character sets, such as UTF-16</p></li><li><p><strong>char32_t</strong>: A type for holding 32-bit character sets, such as UTF-32</p></li></ul></li><li><p>char类型字面值（literal）书写形式为<strong>一对单引号包围的</strong></p><blockquote><p>单个字符：’0’，’a’，’A’</p><p>转义形式：’\n’, ‘\r’, ‘\t’ , ‘\b’, ‘\a’ , ‘\‘, ‘\‘’ , ‘\“‘</p><p>十六进制形式：如’2’可表示为’\x32’</p><p>八进制形式：如’2’可表示为’\062’</p></blockquote></li><li><p><strong>A <u>char</u> must identically to either a <u>signed char</u> or an <u>unsinged char</u></strong>, you can’t mix pointers to different char types</p><pre class=" language-c++"><code class="language-c++">oid f(char c, signed char sc, unsigned char uc){char∗ pc = &uc; // error : no pointer conversionsigned char∗ psc = pc; // error : no pointer conversionunsigned char∗ puc = pc; // error : no pointer conversionpsc = puc; // error : no pointer conversion}</code></pre></li></ul><h3 id="Integer-Types"><a href="#Integer-Types" class="headerlink" title="Integer Types"></a>Integer Types</h3><ul><li><img src="images/image-20210319185002504.png" alt="image-20210319185002504"></li><li><img src="images/image-20210319190301927.png" alt="image-20210319190301927"></li></ul><h3 id="Floating-Point-Types"><a href="#Floating-Point-Types" class="headerlink" title="Floating-Point Types"></a>Floating-Point Types</h3><ul><li><p>There are three floating-point types: <strong>float (single-precision)</strong>, <strong>double (double-precision)</strong>, and <strong>long double (extended-precision)</strong></p></li><li><p>浮点数字面值的书写形式：</p><blockquote><p>整数部分.小数部分[e|E]$\pm$整数[f|F|L|l]</p><p><strong>之间不能有空格</strong></p><p>后缀为f或F为float，为l或L为long double，什么都不加为double</p><ul><li><p>some examples</p><pre class=" language-c++"><code class="language-c++">1.23 0.23 1. 1.0 1.2e10 1.23e-153.14159265f 2.0f 2.997925F 2.9e−3f    //float3.14159265L 2.0L 2.997925L 2.9e−3L    //double</code></pre></li></ul></blockquote></li></ul><h3 id="Sizes"><a href="#Sizes" class="headerlink" title="Sizes"></a>Sizes</h3><ul><li><strong>C++</strong>标准中规定，无论在哪种平台上，都把<strong>一个char 类型值的存储空间尺寸作为存储空间分配的最小基本单位</strong>（记做1），其他类型值的存储空间分配量都是这个基本单位量的整数倍<ul><li>N could be <strong>char, short, int, long, or long long</strong><img src="images/image-20210319191447838.png" alt="image-20210319191447838"></li><li>It’s extremely unwise to <strong>assume that the size of an int is the same as the size of a pointer</strong></li><li>It’s not guaranteed that <strong>sizeof(long)&lt;sizeof(long long) or that sizeof(double)&lt;sizeof(long double)</strong></li></ul></li></ul><h3 id="Void"><a href="#Void" class="headerlink" title="Void"></a>Void</h3><ul><li><p>值集：$\varnothing$</p></li><li><p>一般只用来表示<strong>不返回值的函数</strong>，以及构造出<strong>通用指针类型（void*）</strong>，来指向类型不限或者类型不可预知的对象</p><pre class=" language-c++"><code class="language-c++">void qsort(void* base,size_t num,size_t size,int (*compar)(const void*,const void*))</code></pre></li><li><p>some examples:</p><pre class=" language-c++"><code class="language-c++">void x; // error : there are no void objectsvoid& r; // error : there are no references to voidvoid f(); // function f does not return a value void∗ pv; // pointer to object of unknown type </code></pre></li></ul><h3 id="Enumerations"><a href="#Enumerations" class="headerlink" title="Enumerations"></a>Enumerations</h3><ul><li>值集中的每个值：一个已<strong>命名的整数常量（Named integer constant）</strong>，该名字就是该枚举类型的一个字面值（enumerator，枚举符）</li><li><img src="images/image-20210319192026595.png" alt="image-20210319192026595"></li><li><img src="images/image-20210319193536313.png" alt="image-20210319193536313"></li></ul><h3 id="Declarations"><a href="#Declarations" class="headerlink" title="Declarations"></a>Declarations</h3><ul><li><p><strong>Before a name (identifier) can be used in a C++ program, it must be declared. That is, its type must be specified to inform the compiler what kind of entity the name refers to</strong>.</p></li><li><p>for examples:</p><pre class=" language-c++"><code class="language-c++">char ch;string s;auto count = 1;const double pi {3.1415926535897};extern int error_number;const char∗ name = "Njal";const char∗ season[] = { "spring", "summer", "fall", "winter" };vector<string> people { name, "Skarphedin", "Gunnar" };struct Date { int d, m, y; };int day(Date∗ p) { return p−>d; }double sqrt(double);template<class T> T abs(T a) { return a<0 ? −a : a; }constexpr int fac(int n) { return (n<2)?1:n∗fac(n−1); } // possible compile-time evaluation (§2.2.3)constexpr double zz { ii∗fac(7) }; // compile-time initializationusing Cmplx = std::complex<double>; // type alias (§3.4.5, §6.5)struct User; // type nameenum class Beer { Carlsberg, Tuborg, Thor };namespace NS { int a; }</code></pre><ul><li>A declarations consists of four parts: <strong>an optional specifier, a base type, a declarator, an optional initializer</strong><img src="images/image-20210319194257507.png" alt="image-20210319194257507"></li></ul></li><li><p>What’s the difference between declaration and definition?</p><ul><li><pre class=" language-c++"><code class="language-c++">char ch; // set aside memory for a char and initialize it to 0auto count = 1; // set aside memory for an int initialized to 1const char∗ name = "Njal"; // set aside memory for a pointer to char// set aside memory for a string literal "Njal"// initialize the pointer with the address of that string literalstruct Date { int d, m, y; }; // Date is a struct with three membersint day(Date∗ p) { return p−>d; } // day is a function that executes the specified codeusing Point = std::complex<shor t>;// Point is a name for std::complex<shor t</code></pre></li><li><p>only these are not definitions:</p><pre class=" language-c++"><code class="language-c++">double sqrt(double); // function declarationextern int error_number; // variable declarationstruct User; // type name declaration</code></pre></li><li><p><strong>A definition is a declaration that supplies all that is needed in a program for the use of an entity.</strong></p></li><li><p>more examples:</p><pre class=" language-c++"><code class="language-c++">int count;int count;//error redifinitionextern int error_number;extern short error_number;//error:type mismatchextern int error_number;extern int error_number;//OK：redeclaration</code></pre></li><li><p>对于变量（对象）声明，若<strong>没有描述符extern</strong>，或它<strong>带有初始式</strong>，则为定义，否则仅为非定义声明</p></li><li><p>对于函数声明，若带有函数体，则为定义，否则仅为非定义声明</p></li><li><p>一个enum, struct, union, class, 若带有其所有成员的声明，那么它就是一个定义，否则仅为非定义声明</p></li><li><p>名字空间（namespace）只有定义声明，而没有非定义声明的形式</p><pre class=" language-c++"><code class="language-c++">namespace  N  {//定义         int  x, y;//成员可以是定义声明，            int  f();//也可以是非定义声明  }//N的其他成员可能在别的地方声明</code></pre></li><li><p><img src="images/image-20210319200543101.png" alt="image-20210319200543101"></p></li><li><p>Except for function and namespace definitions, a declaration is terminated by a semicolon<img src="images/image-20210319200728160.png" alt="image-20210319200728160"></p></li></ul></li></ul><h3 id="Names"><a href="#Names" class="headerlink" title="Names"></a>Names</h3><ul><li>Definition from the book: <strong>A name (identifier) consists of a sequence of letters and digits</strong>. <strong>The first character must be a letter</strong>. The <strong>underscore character, _, is considered a letter</strong>. C++ imposes <strong>no limit on the number of characters in a name</strong>. However, some parts of an implementation are not under the control of the compiler writer (in particular, the linker), and those parts, unfortunately, sometimes do impose limits. Some run-time environments also make it necessary to extend or restrict the set of characters accepted in an identifier. Extensions (e.g., allowing the character $ in a name) yield nonportable programs. A C++ keyword (§6.3.3.1), such as <strong>new</strong> or <strong>int,</strong> c<strong>annot be used as a name of a user-defined entity.</strong> </li><li>Examples of names are:<img src="images/image-20210319201801236.png" alt="image-20210319201801236"></li><li>Examples of wrong names:<img src="images/image-20210319201857843.png" alt="image-20210319201857843"></li></ul><h3 id="Scope"><a href="#Scope" class="headerlink" title="Scope"></a>Scope</h3><ul><li><p>The scope of <strong>a global name</strong> (declared outside any function, class, or namespace<em>)</em> extends from <strong>its point of declaration to the end of the file</strong> in which its declaration occurs.</p></li><li><p>The scope of <strong>a local name</strong> (declared in a <em>block</em>, function, class, namespace) extends from <strong>its point of declaration to the end of the block</strong> in which its declaration occurs.</p></li><li><p>A declaration of <strong>a name in a <em>inner block</em> can hide a declaration in an <em>enclosing block</em> or a global name;</strong> After exit from the block, the hidden name resumes its previous meaning</p><pre class=" language-c++"><code class="language-c++">int x; // global xvoid f(){int x; // local x hides global xx = 1; // assign to local x{int x; // hides first local xx = 2; // assign to second local x}x = 3; // assign to first local x}int∗ p = &x; // take address of global x</code></pre></li></ul><ul><li><p>A hidden global name can be referred to <strong>using the scope resolution operator :: (作用域解析符)</strong>. There is no way to use a hidden local name</p><pre class=" language-c++"><code class="language-c++">int x;void f2(){int x = 1; // hide global x::x = 2; // assign to global xx = 2; // assign to local x// ...}</code></pre></li></ul><h3 id="Typedef"><a href="#Typedef" class="headerlink" title="Typedef"></a>Typedef</h3><ul><li><p>A declaration prefixed by the keyword <strong>typedef</strong> declares a new name for the type</p></li><li><p>•The <em>typedef</em> is a synonym（<strong>同义词</strong>） for other type rather than <u>a distinct type</u>. </p></li><li><p>for example</p><pre class=" language-c++"><code class="language-c++">//if you wanna get two pointers to charchar* p1,p2;//ERROR:p1 is char*,p2 si chartypedef char* P2char;P2char p1,p2;//p1 and p2 are char*</code></pre></li></ul><h2 id="Pointers-Arrays-and-Structures"><a href="#Pointers-Arrays-and-Structures" class="headerlink" title="Pointers, Arrays, and Structures"></a>Pointers, Arrays, and Structures</h2><ul><li>程序运行时的内存-概念模型<img src="images/image-20210319211149228.png" alt="image-20210319211149228"></li></ul><h3 id="Pointers"><a href="#Pointers" class="headerlink" title="Pointers"></a>Pointers</h3><ul><li><p>For a type T, T∗ is the type ‘‘pointer to T.’’ That is, a variable of type T∗ can <strong>hold the address of an object of type T</strong></p><ul><li><p>for examples:</p><pre class=" language-c++"><code class="language-c++">char c = 'a';char∗ p = &c;//p holds the address of c; & is the address-of operator</code></pre></li><li><p>graphically: </p><p><img src="images/image-20210319212212684.png" alt="image-20210319212212684"></p></li></ul></li><li><p>‘*’:  dereference operator</p></li><li><p>‘&amp;’: address-of operator</p></li><li><p>more examples:</p><pre class=" language-c++"><code class="language-c++">nt∗ pi; // pointer to intchar∗∗ ppc; // pointer to pointer to charint∗ ap[15]; // array of 15 pointers to intsint (∗fp)(char∗); // pointer to function taking a char* argument; returns an intint∗ f(char∗); // function taking a char* argument; returns a pointer to int//*和&是一对互逆操作,下面两个例子都成立*(&c)=c&(*p)=p</code></pre></li><li><p>Pointer to Function</p><blockquote><p>There are ONLY two things one can do to a function: <em>call it</em> and <strong>take its address</strong></p></blockquote><ul><li><img src="images/image-20210319213324399.png" alt="image-20210319213324399"></li><li><img src="images/image-20210319213345642.png" alt="image-20210319213345642"></li><li><img src="images/image-20210319213415381.png" alt="image-20210319213415381"></li></ul></li><li><p>about nullptr</p><ul><li><p>The literal nullptr represents the null pointer, that is, <strong>a pointer that does not point to an object</strong>. It can be assigned to any pointer type, but <strong>not to other built-in types:</strong></p><pre class=" language-c++"><code class="language-c++">int∗ pi = nullptr;double∗ pd = nullptr;int i = nullptr; // error : i is not a pointer</code></pre></li><li><p>Before nullptr was introduced, zero (0) was used as a notation for the null pointer</p><pre class=" language-c++"><code class="language-c++">int∗ x = 0; // x gets the value nullptr</code></pre></li><li><p>It has been popular to define a macro NULL to represent the null pointer.</p><pre class=" language-c++"><code class="language-c++">int∗ p = NULL; // using the macro NULL</code></pre></li><li><p>However, there are differences in the definition of NULL in different implementations; for example, <strong>NULL might be 0 or 0L</strong>. I<u>n C, NULL is typically (void∗)0</u>, which makes it illegal in C++</p><pre class=" language-c++"><code class="language-c++">int∗ p = NULL; // error : can’t assign a void* to an int*</code></pre></li><li><p>But most of C++ compilers have inherited the use of   macro NULL, so it’s fine if you wanna use it</p></li></ul></li></ul><h3 id="Arrays"><a href="#Arrays" class="headerlink" title="Arrays"></a>Arrays</h3><ul><li><p>For a type T, T[size] is the type ‘‘array of size elements of type T.’’ The elements are indexed from 0 to size−1</p></li><li><p>for examples: (<strong>T can’t be void, but void* is fine</strong>)</p><pre class=" language-c++"><code class="language-c++">float v[3]; // an array of three floats: v[0], v[1], v[2]char∗ a[32]; // an array of 32 pointers to char: a[0] .. a[31]</code></pre></li><li><p>The number of elements of the array, the array bound, must be <strong>a constant expression</strong></p><pre class=" language-c++"><code class="language-c++">void f(int n){int v1[n]; // error : array size not a constant expressionvector<int> v2(n); // OK: vector with n int elements}</code></pre></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Chinese Ring Puzzle</title>
      <link href="/2020/06/24/jiu-lian-huan/"/>
      <url>/2020/06/24/jiu-lian-huan/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="这里是一些规则"><a href="#这里是一些规则" class="headerlink" title="这里是一些规则:"></a>这里是一些规则:</h2><ol><li><p>直接下第一环或者第二环或者两者皆下</p></li><li><p>想要下第n环必须保证第n-1环在上，而前n-2环在下</p></li><li><p>上环过程为1、2过程的逆过程 </p><h2 id="以下是用Java语言实现的代码"><a href="#以下是用Java语言实现的代码" class="headerlink" title="以下是用Java语言实现的代码"></a>以下是用Java语言实现的代码</h2></li></ol><pre class=" language-Java"><code class="language-Java">import java.util.Scanner;public class NineChainOfRings {    public static void main(String[] args) {        Scanner input = new Scanner(System.in);        System.out.print("请输入环的个数：");        int numberOfRings = input.nextInt();        ringDown(numberOfRings);        System.out.println("总共所需步数："+count);    }        static int count = 0;    public static void ringDown(int n){        if(n > 2){            //想要下第n环必须先下前n-2环            ringDown(n - 2);        }        if(n == 2){            //简化操作，直接下前一二环            System.out.println("前一二环一起下");        }else{            //第一步已下好前n-2环，故可下第n环            System.out.println("下第"+n+"环");        }        count++;        if(n > 2){            //想要下第n-1环，先上前n-2环            ringUp(n - 2);        }        if(n > 2){            //问题从下载前n环变为下载前n-1环            //继续递归            ringDown(n - 1);        }    }        /*上环实为下环的逆过程，        * 在此不再赘述，请读者        * 自行查看        * */    public static void ringUp(int n){            if(n > 2){                ringUp(n - 1);            }            if(n == 2){                System.out.println("前一二环一起上");            }else{                System.out.println("上第"+n+"环");            }        count++;        if(n >2){                ringDown(n - 2);            }            if(n > 2){                ringUp(n - 2);            }    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Recursion </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>how to install graphviz</title>
      <link href="/2020/06/16/graphviz-install/"/>
      <url>/2020/06/16/graphviz-install/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Here-is-the-answer"><a href="#Here-is-the-answer" class="headerlink" title="Here is the answer:"></a>Here is the answer:</h1><pre><code>1. open your anaconda prompt2. input:  + conda install -c anaconda graphviz python-graphviz3. it works for me and I believe it will do the same for you too</code></pre>]]></content>
      
      
      <categories>
          
          <category> MachineLearning </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>mysql基础笔记</title>
      <link href="/2020/05/24/mysql-ji-chu-zhi-ling-bi-ji/"/>
      <url>/2020/05/24/mysql-ji-chu-zhi-ling-bi-ji/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="MySQL基础指令笔记："><a href="#MySQL基础指令笔记：" class="headerlink" title="MySQL基础指令笔记："></a>MySQL基础指令笔记：</h1><p>若无说明则默认每句代码后面需要加 “;”</p><h2 id="登陆与退出"><a href="#登陆与退出" class="headerlink" title="登陆与退出:"></a>登陆与退出:</h2><ol><li><p>[数据库文件夹名]  -u+用户名 -p+密码(建议-p后先回车再输入密码更为安全)  </p></li><li><p>使用exit 或者 quit加enter 退出</p></li></ol><p>注释：    </p><ol><li><p>单行注释： – 文字 或者 # 文字  </p></li><li><p>多行注释：/*文字段*/</p></li></ol><h2 id="操作数据库："><a href="#操作数据库：" class="headerlink" title="操作数据库："></a>操作数据库：</h2><ol><li>创建数据库：  <ul><li>create database 数据库名</li><li>create database if not exists 数据库名  </li><li>可在数据库名称后面增加character set 字符集名称，如character set utf8 或者  character set gbk  </li></ul></li><li>查询：  <ol><li>show databases (所有数据库)          </li><li>show create database 数据库名称(查看单个数据库)  </li></ol></li><li>修改：  <pre><code>* alter database 数据库名称 character set 字符集名称(修改数据库的字符集名称)  </code></pre></li><li>删除：  <ol><li>drop database 数据库名称   </li><li>drop database if exists 数据库名称  </li></ol></li><li>使用数据库：  <ol><li>use 数据库名称 </li><li>select database() 查看当前数据库名称  </li></ol></li><li>备份与还原数据库：<ol><li>备份：mysqldump -u[username] -p[password]  databasename &gt;url[保存路径]  </li><li>还原：新建数据库后使用 source url[备份路径]</li></ol></li></ol><h2 id="操作表："><a href="#操作表：" class="headerlink" title="操作表："></a>操作表：</h2><ol><li>表的创建(举例演示)：  </li></ol><pre class=" language-mysql"><code class="language-mysql">create table employee(    name varchar(), --在括号内输入整数表示字符多少    id int,    birthday date, --格式为yyyy-mm-dd    entrytime datetime(也可使用时间戳timestamp，时间戳默认为当前时间), --格式为yyyy-mm-dd hh:mm:ss);</code></pre><p><strong>最后一个参数后面无需逗号</strong>  </p><ol start="2"><li><p>表的复制：<br>create table 表名 like 需要复制的表名  </p></li><li><p>查询：  </p><ul><li>所有表：show tables  </li><li>单张表: desc 表名  </li></ul></li><li><p>表的修改：  </p><ol><li>表名：alter table 表名 rename to 新的表名  </li><li>修改字符集： 同数据库的设置字符集操作  </li><li>新增一列：alter table 表名 add 列名 数据类型   </li><li>修改列名和数据类型：alter tabe 表名 modify(change) 列名 <a href="如果需要修改列名，可不写">新列名</a> 新数据类型  </li><li>删除列：alter table 表名 drop 列名  </li></ol></li><li><p>删除表:  </p><ul><li><p>drop table 表名  </p></li><li><p>drop table if exists 表名(与操作数据库时相同，添加if语句更加安全)       </p></li></ul></li></ol><h2 id="操作表中数据"><a href="#操作表中数据" class="headerlink" title="操作表中数据:"></a>操作表中数据:</h2><p>​    1. 添加数据：  </p><p>​        * insert into 表名(列名1，列名2，…)values(数据1，数据2，…);    </p><pre class=" language-mysql"><code class="language-mysql">insert into student(name,id,gender,age) values ('张三',1,'男',30),('潘阿拉贡','女',16),('狄仁杰','男',23);</code></pre><ul><li><p>注意事项:  </p></li><li><p>列名可只写部分，但是后面的值输入要与列名的数据类型<em>一一对应</em>  。      </p></li><li><p>若表名后不写列名，则默认为所有列  </p></li><li><p>字符类型用’或者”来都可      </p><ol start="2"><li>删除数据：  <ul><li>delete from 表名 [^where 条件]</li></ul></li></ol><p>   [^where 条件]: 可选操作</p><ul><li><p>注意事项：  </p><ol><li>不加条件则默认<strong>全部删除</strong>  </li></ol></li></ul><ol start="2"><li><p>使用truncate table 表名[^效率更高] </p><p>[^效率更高]:先删除原先的表再创建新表</p></li></ol><ol start="3"><li><p>修改数据：  </p><ul><li>update 表名 set 列名1 = 值1,列名2 = 值2,… [^where 条件]</li></ul><p> [^where 条件]:可选,但若不加条件则默认全部数据都会被更改</p></li></ol></li></ul><h2 id="查询表数据："><a href="#查询表数据：" class="headerlink" title="查询表数据："></a>查询表数据：</h2><p>​     1. select 列名，聚合函数，可多选(也可使用*，代表所有内容) from 表名 条件(可选)   </p><pre class=" language-mysql"><code class="language-mysql">select * from student; --查询student表中的全部数据select id,age from student; --只显示id和age两列数据select * from student order by id [条件]; --默认为按id大小升序排列,条件asc为升序，desc为降序select * from student order by age asc,id asc; --在满足第一个排序条件后再进行第二轮排序(及在学生年龄相同时再通过学号大小进行排序)</code></pre><ol start="2"><li><p>聚合函数(可放在select或者from之后作为条件，聚合函数不计算null值)     </p><ul><li>count()：用于计算数据个数      <ul><li>若想把null值加入可选择ifnull函数：count(ifnull(可能为null的值,想要修改成的值))</li></ul></li><li>max()：计算最大值</li><li>min(): 计算最小值</li><li>sum(): 计算和</li><li>avg(): 计算平均值</li></ul><ol start="3"><li>条件以及常用的表达式  </li></ol><pre class=" language-mysql"><code class="language-mysql">#whereselect * from where age >15;select * from where age != 15;select * from where age <> 15; --与第二句类似select * from where age >15 &&(and) age<30;select * from student where age in (13,16,49);--只查询年龄为这三个数值之一的数据select * from student where score is not null;--分数不为空的学生#注意，null值只可通过 is 或者 is not 来判断#like(模糊查询)select * from student where name like '钟%'；--查询名字开头为钟的数据select * from student where name like '_钟%';--查询名字第二个字为钟的数据select * from student where name like '%钟%';--查询只要名字中含有钟字的数据select * from student where age between 10 and 20; --同age >=10 and age <= 20#group by(分组)select gender,avg(score),count(id) from student group by gender; --及将学生按性别分为两行，每行包括性别、平均分、总人数select gender,avg(score),count(id) from student where score>70 group by sex having count(id)>2;--与上一行类似，但选择的学生score要大于70，并在分组后的每组人数需大于2#limit(分页查询)select * from student limit firstindex,number; --从指定的索引firstindex开始展示出number数量的数据 </code></pre><ul><li><p>可在from后的列名前加上distinct来去除重复项   </p><pre><code>+ select distinct age from student;       </code></pre></li></ul><h2 id="约束"><a href="#约束" class="headerlink" title="约束:"></a>约束:</h2><p>  1.分类：  </p><ul><li><p>主键约束：primary key</p><ul><li><pre class=" language-mysql"><code class="language-mysql">create table student(    id int primary key,    --增加主键约束，id值唯一且非null    --一张表只允许一列出现主键    name varchar(20))</code></pre></li></ul></li></ul><ul><li><p>唯一约束：unique</p><ul><li><pre class=" language-mysql"><code class="language-mysql">create table student(    id int unique,    --id唯一但可以为null    --可以为多列使用    name varchar(20) unique)</code></pre></li></ul></li><li><p>非空约束：not null</p><ul><li><pre class=" language-mysql"><code class="language-mysql">create table student(    id int,    name varchar(15) not null    --学生姓名不能为空)</code></pre></li></ul></li><li><p>外键约束：foreign key</p><ul><li><pre class=" language-mysql"><code class="language-mysql">create table classroom(    class_id int constraint for_key foreign key id references student,    --constraint后为外键名称，可随意命名    --使教室的id与学生表中的id联系起来)</code></pre></li></ul></li><li><p>增删主键：</p><ul><li>alter table [表名] drop primary key  –delete</li><li>alter table [表名] modify [列名] [列的数据类型] primary key  –add  </li></ul></li><li><p>增删唯一：</p><ul><li>alter table [表名] drop index [列名]</li><li>alter table [表名] modify [列名] [列的数据类型] unique</li></ul></li><li><p>增删非空约束：</p><ul><li>alter table [表名] modify [列名] [列的数据类型] </li><li>alter table [表名] modify [列名] [列的数据类型] not null</li></ul></li><li><p>增删外键：</p><ul><li>alter table [表名] drop foreign key [外键名称]</li><li>alter table [表名] add constraint [外键名称] foreign key [列名] references [另表列名]</li></ul></li><li><p>其他操作：</p><ul><li>在外键创建时加入on update cascade 可以让两表的数据同步更新</li><li>on delete cascade 解除同步更新 </li><li>auto_increment 自动增长，可放在数据类型之后</li></ul></li></ul><h2 id="事务："><a href="#事务：" class="headerlink" title="事务："></a>事务：</h2><ol><li>开启事务：start transaction</li><li>提交：commit</li><li>回滚：rollback</li><li>提交方式：@@autocommit (1为自动，0为手动)<ol><li>select @@autocommit –查询</li><li>set @@autocommit = 0/1 –修改</li></ol></li><li>隔离等级(从上往下等级依次增强)：<ol><li>read uncommitted </li><li>read committed</li><li>repeatable read</li><li>serializable<ul><li>查询：select @@tx_isolation</li><li>设置： set global transaction isolation [隔离等级]</li></ul></li></ol></li></ol><h2 id="权限管理"><a href="#权限管理" class="headerlink" title="权限管理"></a>权限管理</h2><ol><li>添加用户：create user ‘username’@’localhost’ identified by ‘password’</li><li>删除用户：drop user ‘username’@’localhost’</li><li>修改密码： <pre><code>* update user set password = password(&#39;new password&#39;) where user = &#39;username&#39;* set password for &#39;username&#39;@&#39;localhost&#39; = password(&#39;new password&#39;)</code></pre></li><li>权限查询： show grants for ‘username’@’localhost’</li><li>权限授予：<ul><li>grant [权限] on databasename.listname to ‘username’@’localhost’</li><li>grant all on <em>.</em> to ‘username’@’localhost’ –add all authority</li></ul></li><li>权限撤销：<ol><li>revoke [权限] on databasename.listname from ‘username’@’localhost’</li></ol></li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>How Are You Doing?</title>
      <link href="/2020/02/17/myfirstpost/"/>
      <url>/2020/02/17/myfirstpost/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> Markdown </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
